## 前言 {#articleHeader0}

**总括：**本文详细讲述了RSA算法详解，包括内部使用数学原理以及产生的过程。

* 原文博客地址：[RSA算法详解](http://blog.damonare.cn/2017/12/31/RSA算法详解/#more)
* 知乎专栏&&简书专题：[前端进击者（知乎）](https://zhuanlan.zhihu.com/damonare)&&[前端进击者（简书）](http://www.jianshu.com/collection/bbaa63e264f5)
* 博主博客地址：[Damonare的个人博客](http://damonare.cn/)

**相濡以沫。到底需要爱淡如水。**

## 正文 {#articleHeader1}

之前写过一篇文章[SSL协议之数据加密过程](http://blog.damonare.cn/2017/12/29/SSL协议之数据加密过程详解/#more)，里面详细讲述了数据加密的过程以及需要的算法。SSL协议很巧妙的利用对称加密和非对称加密两种算法来对数据进行加密。这篇文章主要是针对一种最常见的非对称加密算法——RSA算法进行讲解。其实也就是对私钥和公钥产生的一种方式进行描述。首先先来了解下这个算法的历史：

### RSA算法的历史 {#articleHeader2}

RSA是1977年由[罗纳德·李维斯特](https://zh.wikipedia.org/wiki/罗纳德·李维斯特)（Ron Rivest）、[阿迪·萨莫尔](https://zh.wikipedia.org/wiki/阿迪·萨莫尔)（Adi Shamir）和[伦纳德·阿德曼](https://zh.wikipedia.org/wiki/伦纳德·阿德曼)（Leonard Adleman）一起提出的。当时他们三人都在[麻省理工学院](https://zh.wikipedia.org/wiki/麻省理工学院)工作。RSA就是他们三人姓氏开头字母拼在一起组成的。

但实际上，在1973年，在英国政府通讯总部工作的数学家[克利福德·柯克斯](https://zh.wikipedia.org/w/index.php?title=克利福德·柯克斯&action=edit&redlink=1)（Clifford Cocks）在一个内部文件中提出了一个相同的算法，但他的发现被列入机密，一直到1997年才被发表。

所以谁是RSA算法的发明人呢？不好说，就好像贝尔并不是第一个发明电话的人但大家都记住的是贝尔一样，这个地方我们作为旁观者倒不用较真，重要的是这个算法的内容：

### RSA算法的过程 {#articleHeader3}

RSA算法用到的数学知识特别多，所以在中间介绍这个算法生成私钥和公钥的过程中会穿插一些数学知识。生成步骤如下：

#### 1. 寻找两个不相同的质数

随意选择两个大的质数p和q，p不等于q，计算N=p\*q;

什么是质数?我想可能会有一部分人已经忘记了，定义如下：

> 除了1和该数自身外，无法被其他自然数整除的数（也可定义为只有1该数本身两个正因数\]的数）。

比如2，3，5，7这些都是质数，9就不是了，因为3\*3=9了

#### 2. 根据欧拉函数获取r

_r = φ\(N\) = φ\(p\)φ\(q\) = \(p-1\)\(q-1\)_。

这里的数学概念就是什么是欧拉函数了，什么是欧拉函数呢？

**欧拉函数**的定义：

> **欧拉函数**_φ\(n\)_是小于或等于_n_的正整数中与_n_互质的数的数目。

**互质**的定义：

> 如果两个或两个以上的整数的最大公约数是 1，则称它们为**互质**

例如：_φ\(8\) = 4_，因为_1,3,5,7_均和_8_互质。

**推导欧拉函数:**

（1）如果_n = 1_,_φ\(1\) = 1_；\(小于等于1的正整数中唯一和1互质的数就是1本身\)；

（2）如果_n_为质数，_φ\(n\) = n - 1_；因为质数和每一个比它小的数字都互质。比如5，比它小的正整数1,2,3,4都和他互质；

（3） 如果_n_是_a_的_k_次幂，则_φ\(n\) = φ\(a^k\) = a^k - a^\(k-1\) = \(a-1\)a^\(k-1\)_；

（4）若_m_,_n_互质，则_φ\(mn\) = φ\(m\)φ\(n\)_

**证明：**设_A_,_B_,_C_是跟_m_,_n_,_mn_互质的数的集，据[中国剩余定理](https://zh.wikipedia.org/wiki/中國剩餘定理)\(经常看数学典故的童鞋应该了解，剩余定理又叫韩信点兵，也叫孙子定理\)，_A_\*_B_和_C_可建立双射一一对应\)的关系。（或者也可以从初等代数角度给出[欧拉函数积性的简单证明](https://zh.wikipedia.org/w/index.php?title=欧拉函数积性的简单证明&action=edit&redlink=1)） 因此的φ\(n\)值使用[算术基本定理](https://zh.wikipedia.org/wiki/算術基本定理)便知。（来自维基百科）

#### 3. 选择一个小于r并与r互质的整数e

选择一个小于r并与r互质的整数e，求得e关于r的模反元素，命名为_d_（_ed = 1\(mod r\)_模反元素存在，当且仅当e与r互质），_e_我们通常取65537。

**模反元素：**

> 如果两个正整数a和n互质，那么一定可以找到整数_b_，使得 ab-1 被n整除，或者说ab被n除的余数是1。

比如_3_和_5_互质，_3_关于_5_的模反元素就可能是2，因为_3\*2-1=5_可以被5整除。所以很明显模反元素不止一个，2加减5的整数倍都是3关于5的模反元素_{...-3, 2,7,12…}_放在公式里就是_3\*2 = 1 \(mod 5\)_

上面所提到的欧拉函数用处实际上在于欧拉定理：

**欧拉定理：**

> 如果两个正整数_a_和_n_互质，则_n_的欧拉函数_φ\(n\)_可以让下面的等式成立：  
> _a^φ\(n\) = 1\(mod n\)_
>
> 由此可得：_a_的_φ\(n - 1\)_次方肯定是_a_关于_n_的模反元素。

欧拉定理就可以用来证明模反元素必然存在。

由模反元素的定义和欧拉定理我们知道，_a_的_φ\(n\)_次方减去1，可以被n整除。比如，3和5互质，而_5_的欧拉函数_φ\(5\)_等于4，所以_3_的_4_次方_\(81\)_减去1，可以被_5_整除（_80/5=16_）。

**小费马定理：**

> 假设正整数a与质数p互质，因为质数p的_φ\(p\)_等于_p-1_，则欧拉定理可以写成  
> _a^\(p-1\) = 1 \(mod p\)_
>
> 这其实是欧拉定理的一个特例。

#### 4. 销毁p和q

此时我们的_\(N , e\)_是公钥，_\(N, d\)_为私钥，爱丽丝会把公钥_\(N, e\)_传给鲍勃，然后将_\(N, d\)_自己藏起来。一对公钥和私钥就产生了，然后具体的使用方法呢？请看：[SSL协议之数据加密过程详解](http://blog.damonare.cn/2017/12/29/SSL协议之数据加密过程详解/#more)

### RSA算法的安全性 {#articleHeader4}

我们知道像RSA这种非对称加密算法很安全，那么到底为啥子安全呢？  
我们来看看上面这几个过程产生的几个数字：

* _p,q_：我们随机挑选的两个大质数；
* _N_：是由两个大质数_p_和_q_相乘得到的。_N = p \* q_；
* _r_：由欧拉函数得到的_N_的值，_r = φ\(N\) = φ\(p\)φ\(q\) = \(p-1\)\(q-1\)_。
* _e_：随机选择和和_r_互质的数字，实际中通常选择65537；
* _d_： d是以欧拉定理为基础求得的e关于r的模反元素，_ed = 1 \(mod r\)_；

_N_和_e_我们都会公开使用，最为重要的就是私钥中的_d_，_d_一旦泄露，加密也就失去了意义。那么得到d的过程是如何的呢？如下:

1. 比如知道e和r，因为d是e关于r的模反元素；r是φ\(N\) 的值
2. 而_φ\(N\)=\(p-1\)\(q-1\)_，所以知道p和q我们就能得到d;
3. _N = pq_，从公开的数据中我们只知道N和e，所以问题的关键就是对N做因式分解能不能得出p和q

所以得出了在上篇博客说到的结论，非对称加密的原理：

**将a和b相乘得出乘积c很容易，但要是想要通过乘积c推导出a和b极难。即对一个大数进行因式分解极难**

目前公开破译的位数是768位，实际使用一般是1024位或是2048位，所以理论上特别的安全。

## 后记 {#articleHeader5}

RSA算法的核心就是欧拉定理，根据它我们才能得到私钥，从而保证整个通信的安全。

> 原文，RSA算法详解：[https://segmentfault.com/a/1190000013128367](https://segmentfault.com/a/1190000013128367)



